{
  "version": "0.5.32",
  "name": "apostrophe-schemas",
  "description": "Schemas for easy editing of properties in Apostrophe objects",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/punkave/apostrophe-schemas.git"
  },
  "keywords": [
    "apostrophe",
    "cms",
    "content",
    "management",
    "schemas",
    "mongodb"
  ],
  "author": {
    "name": "P'unk Avenue LLC"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/punkave/apostrophe-schemas/issues"
  },
  "homepage": "https://github.com/punkave/apostrophe-schemas",
  "dependencies": {
    "async": "0.8.x",
    "lodash": "2.4.x",
    "extend": "~1.2.1",
    "moment": "~2.4.0"
  },
  "readme": "# apostrophe-schemas\n\n## Code Status\n\nThis module is now in production use, powering the `apostrophe-snippets` module, and therefore `apostrophe-blog`, `apostrophe-events`, etc. Everything you see here has been tested, with the exception of the \"adding new field types\" section, which has been implemented but not yet tested. If you find issues with that feature (which is not critical for any existing A2 modules) we would welcome bug reports and pull requests.\n\n**Table of Contents**\n  * [Accessing the Schemas Object In Your Module](#accessing-the-schemas-object-in-your-module)\n  * [Adding New Properties To Objects Using the Schema](#adding-new-properties-to-your-snippets-using-the-schema)\n    * [What field types are available?](#what-field-types-are-available)\n    * [Validation](#validation)\n    * [Grouping fields into tabs](#grouping-fields-into-tabs)\n    * [Arrays in schemas](#arrays-in-schemas)\n  * Editing\n    * [Schemas in Nunjucks Templates](#editing-schemas-in-nunjucks-templates)\n    * [Browser-Side JavaScript](#editing-browser-side-javascript)\n    * [Saving Objects On the Server](#editing-saving-objects-on-the-server)\n    * [Editing Fields In Context](#editing-fields-in-context)\n  * [Joins in Schemas](#joins-in-schemas)\n    * [one-to-one](#one-to-one-joins)\n    * [reverse](#reverse-joins)\n    * [nested joins](#nested-joins-you-gotta-be-explicit)\n    * [many-to-many](#many-to-many-joins)\n    * [reverse many-to-many](#reverse-many-to-many-joins)\n    * [Complicated Relationships](#when-relationships-get-complicated)\n    * [Accessing Relationship Properties in a Reverse Join](#accessing-relationship-properties-in-a-reverse-join)\n  * [Overriding Templates For Individual Fields](#overriding-templates-for-individual-fields)\n  * [Adding New Field Types](#adding-new-field-types)\n  * Support for Subclassing and Mixins\n    * [Creating Schemas With Compose](#creating-schemas-with-compose)\n    * [Refining Existing Schemas With Refine](#refining-existing-schemas-with-refine)\n\n`apostrophe-schemas` adds support for simple schemas of editable properties to any object. Schema types include text, select, apostrophe areas and singletons, joins (relationships to other objects), and more. This module is used by the `apostrophe-snippets` module to implement its edit views and can also be used elsewhere.\n\n### Accessing the Schemas Object In Your Module\n\nIn any project built with the [apostrophe-site](http://github.com/punkave/apostrophe-site) module, every module you configure in `app.js` will receive a `schemas` option, which is a ready-to-rock instance of the `apostrophe-schemas` module. You might want to add it as a property in your constructor:\n\n    self._schemas = options.schemas;\n\n**If you are not using `apostrophe-site`... well, you should be.** But a reasonable alternative is to configure `apostrophe-schemas` yourself in `app.js`:\n\n    var schemas = require('apostrophe-schemas')({ app: app, apos: apos });\n    schemas.setPages(pages); // pages module must be injected\n\nAnd then pass it as the `schemas` option to every module that will use it. But this is silly. Use `apostrophe-site`.\n\n### Adding New Properties To Objects Using the Schema\n\nA schema is a simple array of objects specifying information about each field. The `apostrophe-schemass` module provides methods to build schemas, validate submitted data according to a schema, and carry out joins according to a schema. The module also provides browser-side JavaScript and Nunjucks templates to edit an object based on its schema.\n\nSchema objects have intentionally been kept simple so that they can be send to the browser as JSON and interpreted by browser-side JavaScript as well.\n\nThe simplest way to create a schema is to just make an array yourself:\n\n```javascript\nvar schema = [\n    {\n      name: 'workPhone',\n      type: 'string',\n      label: 'Work Phone'\n    },\n    {\n      name: 'workFax',\n      type: 'string',\n      label: 'Work Fax'\n    },\n    {\n      name: 'department',\n      type: 'string',\n      label: 'Department'\n    },\n    {\n      name: 'isRetired',\n      type: 'boolean',\n      label: 'Is Retired'\n    },\n    {\n      name: 'isGraduate',\n      type: 'boolean',\n      label: 'Is Graduate'\n    },\n    {\n      name: 'classOf',\n      type: 'string',\n      label: 'Class Of'\n    },\n    {\n      name: 'location',\n      type: 'string',\n      label: 'Location'\n    }\n  ]\n});\n```\n\nHowever, if you are implementing a subclass and need to make changes to the schema of the superclass it'll be easier for you if the superclass uses the `schemas.compose` method, as described later.\n\n#### What Field Types Are Available?\n\nCurrently:\n\n`string`, `boolean`, `integer`, `float`, `select`, `url`, `date`, `time`, `slug`, `tags`, `password`, `area`, `singleton`\n\nExcept for `area`, all of these types accept a `def` option which provides a default value if the field's value is not specified.\n\nThe `integer` and `float` types also accept `min` and `max` options and automatically clamp values to stay in that range.\n\nThe `select` type accepts a `choices` option which should contain an array of objects with `value` and `label` properties.\n\nThe `date` type pops up a jQuery UI datepicker when clicked on, and the `time` type tolerates many different ways of entering the time, like \"1pm\" or \"1:00pm\" and \"13:00\".\n\nThe `url` field type is tolerant of mistakes like leaving off `http:`.\n\nThe `password` field type stores a salted hash of the password via `apos.hashPassword` which can be checked later with the `password-hash` module. If the user enters nothing the existing password is not updated.\n\nWhen using the `area` and `singleton` types, you may include an `options` property which will be passed to that area or singleton exactly as if you were passing it to `aposArea` or `aposSingleton`.\n\nWhen using the `singleton` type, you must always specify `widgetType` to indicate what type of widget should appear.\n\n[Joins](#joins-in-schemas) and [arrays](#arrays-in-schemas) are also supported as described later.\n\n#### Validation\n\nFor the most part, we favor sanitization over validation. It's better to figure out what the user meant on the server side than to give them a hard time. But sometimes validation is unavoidable.\n\nYou can make any field mandatory by giving it the `required: true` attribute. Currently this is only implemented in browser-side JavaScript, so your server-side code should be prepared not to crash if a property is unexpectedly empty.\n\nIf the user attempts to save without completing a required field, the `apos-error` class will be set on the `fieldset` element for that field, and `schemas.convertFields` will pass an error to its callback. If `schemas.convertFields` passes an error, your code should not attempt to save the object or close the dialog in question, but rather let the user continue to edit until the callback is invoked with no error.\n\nIf `schemas.convertFields` does pass an error, you may invoke:\n\n`aposSchemas.scrollToError($el)`\n\nTo ensure that the first error in the form is visible.\n\nIf you are performing your own custom validation, you can call:\n\n`aposSchemas.addError($el, 'body')`\n\nTo indicate that the field named `body` has an error, in the same style that is applied to errors detected via the schema.\n\n#### Grouping fields into tabs\n\nOne lonnnnng scrolling list of fields is usually not user-friendly.\n\nYou may group fields together into tabs instead using the `groupFields` option. Here's how you would do it if you wanted to override our tab choices for the blog:\n\n```javascript\nmodules: {\n  'apostrophe-blog': {\n    groupFields: [\n      // We don't list the title field so it stays on top\n      {\n        name: 'content',\n        label: 'Content',\n        icon: 'content',\n        fields: [\n          'thumbnail', 'body'\n        ]\n      },\n      {\n        name: 'details',\n        label: 'Details',\n        icon: 'metadata',\n        fields: [\n          'slug', 'published', 'publicationDate', 'publicationTime', 'tags'\n        ]\n      }\n    ]\n  }\n}\n```\n\nEach group has a name, a label, an icon (passed as a CSS class on the tab's icon element), and an array of field names.\n\nIn `app.js`, you can simply pass `groupFields` like any other option when configuring a module. *The last call to `groupFields` wins, overriding any previous attempts to group the fields, so be sure to list all of them* except for fields you want to stay visible at all times above the tabs.\n\n**Be aware that group names must be distinct from field names.** Apostrophe will stop the music and tell you if they are not.\n\n#### Arrays in schemas\n\nLet's say you're managing \"companies,\" and each company has several \"offices.\" Wouldn't it be nice if you could edit a list of offices while editing the company?\n\nThis is easy to do with the `array` field type:\n\n```javascript\n{\n  name: 'offices',\n  label: 'Offices',\n  type: 'array',\n  schema: [\n    {\n      name: 'city',\n      label: 'City',\n      type: 'string'\n    },\n    {\n      name: 'zip',\n      label: 'Zip',\n      type: 'string',\n      def: '19147'\n    },\n    {\n      name: 'thumbnail',\n      label: 'Thumbnail',\n      type: 'singleton',\n      widgetType: 'slideshow',\n      options: {\n        limit: 1\n      }\n    }\n  ]\n}\n```\n\nEach `array` has its own `schema`, which supports all of the usual field types. You an even nest an `array` in another `array`.\n\nIt's easy to access the resulting information in a page template, such as the `show` template for companies. The array property is... you guessed it... an array! Not hard to iterate over at all:\n\n```markup\n<h4>Offices</h4>\n<ul>\n  {% for office in item.offices %}\n    <li>{{ office.city }}, {{ office.zip }}</li>\n  {% endfor %}\n</ul>\n```\n\nAreas and thumbnails are allowed in arrays. In order to display them in a page template,  you'll need to use this syntax:\n\n```markup\n{% for office in item.offices %}\n  {{ aposSingleton({ area: office.thumbnail, type: 'slideshow', more options... }) }}\n{% endfor %}\n```\n\nFor an area you would write:\n\n```markup\n{% for office in item.offices %}\n  {{ aposArea({ area: office.body, more options... }) }}\n{% endfor %}\n```\n\nSince the area is not a direct property of the page, we can't use the `(page, areaname)` syntax that is typically more convenient.\n\nAreas and thumbnails in arrays cannot be edited \"in context\" on a page, they must be updated through the schema editor. However, check out [schema widgets](https://github.com/punkave/apostrophe-schema-widgets) for a way to add widgets powered by schemas anywhere in the flow of a page.\n\n#### Preventing Autocomplete\n\nFor most field types, you may specify:\n\n    autocomplete: false\n\nTo request that the browser not try to autocomplete the field's value for the user. The only fields that do not support this are those that are not implemented by a traditional HTML form field, and in all probability browsers won't autocomplete these anyway.\n\n### Editing: Schemas in Nunjucks Templates\n\nThis is really easy! Just write this in your nunjucks template:\n\n```jinja\n{% include 'schemas:schemaMacros.html' %}\n\n<form class=\"my-form\">\n  {{ schemaFields(schema) }}\n</form>\n```\n\nOf course you must pass your schema to Nunjucks when rendering your template.\n\nAll of the fields will be presented with their standard markup, ready to be populated by `aposSchemas.populateFields` in browser-side JavaScript.\n\nIt is also possible to inject some custom markup around a field. Just output the fields \"before\" a certain point, then the fields \"after\" it:\n\n```jinja\n{{ schemaFields(fields, { before: 'shoeSize' }) }}\n<p>Here comes the shoe size kids!</p>\n{{ schemaText('shoeSize', 'Shoe Size') }}\n<p>Wasn't that great?</p>\n{{ schemaFields(fields, { after: 'shoeSize' }) }}\n{% endblock %}\n```\n\nIn addition to `before` and `from`, you may also use `after` and `to`. `before` and `after` are exclusive, while `from` and `to` are inclusive. Combining `before` and `from` let us wrap something around a specific field without messing up other fields or even having to know what they are.\n\nYes, you can output your own custom markup for fields, provided the markup has the same data attributes and name attributes.\n\nNote that you do not need to supply any arguments that can be inferred from the schema, such as the `choices` list for a `select` property, or the widget type of a singleton. The real initialization work happens in browser-side JavaScript powered by the schema.\n\nYou also need to push your schema from the server so that it is visible to browser-side Javascript:\n\n```javascript\nself._apos.pushGlobalData({\n  mymodule: {\n    schema: self.schema\n  }\n});\n```\n\n### Editing: Browser-Side Javascript\n\nNow you're ready to use the browser-side JavaScript to power up the editor. Note that the `populateFields` method takes a callback:\n\n```javascript\nvar schema = apos.data.mymodule.schema;\naposSchemas.populateFields($el, schema, object, function() {\n  // We're ready\n});\n```\n\n`$el` should be a jQuery object referring to the element that contains all of the fields you output with `schemaFields`. `object` is an existing object containing existing values for some or all of the properties.\n\nAnd, when you're ready to save the content:\n\n```javascript\naposSchemas.convertFields($el, schema, object)\n```\n\nThis is the same in reverse. The properties of the object are set based on the values in the editor. Aggressive sanitization is not performed in the browser because the server must always do it anyway (never trust a browser). You may of course do your own validation after calling `convertFields` and perhaps decide the user is not done editing yet after all.\n\n### Editing: Saving Objects On the Server\n\nSerializing the object and sending it to the server is up to you. (We recommend using `$.jsonCall`.) But once it gets there, you can use the `convertFields` method to clean up the data and make sure it obeys the schema. The incoming fields should be properties of `data`, and will be sanitized and copied to properties of `object`. Then the callback is invoked:\n\n```javascript\nschemas.convertFields(req, schema, 'form', data, object, callback)\n```\n\nThe third argument is set to `'form'` to indicate that this data came from a form and should go through that converter.\n\nNow you can save `object` as you normally would.\n\n### Editing Fields In Context\n\nFor snippets, the entire object is usually edited in a modal dialog. But if you are using schemas to enhance regular pages via the [apostrophe-fancy-pages](https://github.com/punkave/apostrophe-fancy-pages) module, you might prefer to edit certain areas and singletons \"in context\" on the page itself.\n\nYou could just leave them out of the schema, and take advantage of Apostrophe's support for \"spontaneous areas\" created by `aposArea` and `aposSingleton` calls in templates.\n\nAn alternative is to set `contextual` to `false` for such fields. This will keep them out of forms generated by `{{ schemaFields }}`, but will not prevent you from taking advantage of other features of schemas, such as CSV import.\n\nEither way, it is your responsibility to add an appropriate `aposArea` or `aposSingleton` call to the page, as you are most likely doing already.\n\n### Joins in Schemas\n\nYou may use the `join` type to automatically pull in related objects from this or another module. Typical examples include fetching events at a map location, or people in a group. This is very cool.\n\n*\"Aren't joins bad? I read that joins were bad in some NoSQL article.\"*\n\nShort answer: no.\n\nLong answer: sometimes. Mostly in so-called \"webscale\" projects, which have nothing to do with 99% of websites. If you are building the next Facebook you probably know that, and you'll denormalize your data instead and deal with all the fascinating bugs that come with maintaining two copies of everything.\n\nOf course you have to be smart about how you use joins, and we've included options that help with that.\n\n##### One-To-One Joins\n\nYou might write this:\n\n```javascript\n  addFields: [\n    {\n      name: '_location',\n      type: 'joinByOne',\n      withType: 'mapLocation',\n      idField: 'locationId',\n      label: 'Location'\n    }\n  ]\n}\n```\n\n(How does this work? `apostrophe-schemas` will consult the `apostrophe-pages` module to find the manager object responsible for `mapLocation` objects, which will turn out to be the `apostrophe-map` module.)\n\nNow the user can pick a map location. And if you call `schema.join(req, schema, myObjectOrArrayOfObjects, callback)`, `apostrophe-schemas` will carry out the join, fetch the related object and populate the `_location` property of your object. Note that it is much more efficient to pass an array of objects if you need related objects for more than one.\n\nHere's an example of using the resulting ._location property in a Nunjucks template:\n\n```twig\n{% if item._location %}\n  <a href=\"{{ item._location.url | e }}\">Location: {{ item._location.title | e }}</a>\n{% endif %}\n```\n\nThe id of the map location actually \"lives\" in the `location_id` property of each object, but you won't have to deal with that directly.\n\n*Always give your joins a name starting with an underscore.* This warns Apostrophe not to store this information in the database permanently where it will just take up space, then get re-joined every time anyway.\n\nCurrently after the user has selected one item they see a message reading \"Limit Reached!\" We realize this may not be the best way of indicating that a selection has already been made. So you may pass a `limitText` option with an alternative message to be displayed at this point.\n\n##### Joining With \"Regular Pages\"\n\nWhat if you want to allow the user to pick anything at all, as long as it's a \"regular page\" in the page tree with its own permanent URL?\n\nJust use:\n\n```javascript\nwithType: 'page'\n```\n\nThis special case allows you to easily build navigation menus and the like using [schema widgets](https://github.com/punkave/apostrophe-schema-widgets) and [array fields](#arrays-in-schemas).\n\n##### Reverse Joins\n\nYou can also join back in the other direction:\n\n```javascript\n  addFields: [\n    {\n      name: '_events',\n      type: 'joinByOneReverse',\n      withType: 'event',\n      idField: 'locationId',\n      label: 'Events'\n    }\n  ]\n```\n\nNow, in the `show` template for the map module, we can write:\n\n```twig\n{% for event in item._events %}\n  <h4><a href=\"{{ event.url | e }}\">{{ event.title | e }}</a></h4>\n{% endfor %}\n```\n\n\"Holy crap!\" Yeah, it's pretty cool.\n\nNote that the user always edits the relationship on the \"owning\" side, not the \"reverse\" side. The event has a `location_id` property pointing to the map, so users pick a map location when editing an event, not the other way around.\n\n##### Nested Joins: You Gotta Be Explicit\n\n*\"Won't this cause an infinite loop?\"* When an event fetches a location and the location then fetches the event, you might expect an infinite loop to occur. However Apostrophe does not carry out any further joins on the fetched objects unless explicitly asked to.\n\n*\"What if my events are joined with promoters and I need to see their names on the location page?\"* If you really want to join two levels deep, you can \"opt in\" to those joins:\n\n```javascript\n  addFields: [\n    {\n      name: '_events',\n      // Details of the join, then...\n      withJoins: [ '_promoters' ]\n    }\n  ]\n```\n\nThis assumes that `_promoters` is a join you have already defined for events.\n\n*\"What if my joins are nested deeper than that and I need to reach down several levels?\"*\n\nYou can use \"dot notation,\" just like in MongoDB:\n\n```javascript\nwithJoins: [ '_promoters._assistants' ]\n```\n\nThis will allow events to be joined with their promoters, and promoters to be joined with their assistants, and there the chain will stop.\n\nYou can specify more than one join to allow, and they may share a prefix:\n\n```javascript\nwithJoins: [ '_promoters._assistants', '_promoters._bouncers' ]\n```\n\nRemember, each of these later joins must actually be present in the configuration for the module in question. That is, \"promoters\" must have a join called \"_assistants\" defined in its schema.\n\n##### Nested Joins and Arrays\n\nJoins are allowed in the schema of an [array field](#arrays-in-schemas), and they work exactly as you would expect. Just include joins in the schema for the array as you normally would.\n\nAnd if you are carrying out a nested join with the `withJoins` option, you'll just need to refer to the join correctly.\n\nLet's say that each promoter has an array of ads, and each ad is joined to a media outlet. We're joing with events, which are joined to promoters, and we want to make sure media outlets are included in the results.\n\nSo we write:\n\n```javascript\n  addFields: [\n    {\n      name: '_events',\n      // Details of the join, then...\n      withJoins: [ '_promoters.ads._mediaOutlet' ]\n    }\n  ]\n```\n\n#### Many-To-Many Joins\n\nEvents can only be in one location, but stories can be in more than one book, and books also contain more than one story. How do we handle that?\n\nConsider this configuration for a `books` module:\n\n```javascript\n  addFields: [\n    {\n      name: '_stories',\n      type: 'joinByArray',\n      withType: 'story',\n      idsField: 'storyIds',\n      sortable: true,\n      label: 'Stories'\n    }\n  ]\n```\n\nNow we can access all the stories from the show template for books (or the index template, or pretty much anywhere):\n\n```twig\n<h3>Stories</h3>\n{% for story in item._stories %}\n  <h4><a href=\"{{ story.url | e }}\">{{ story.title | e }}</a></h4>\n{% endfor %}\n```\n\n*Since we specified `sortable:true`*, the user can also drag the list of stories into a preferred order. The stories will always appear in that order in the `._stories` property when examinining a book object.\n\n*\"Many-to-many... sounds like a LOT of objects. Won't it be slow and use a lot of memory?\"*\n\nIt's not as bad as you think. Apostrophe typically fetches only one page's worth of items at a time in the index view, with pagination links to view more. Add the objects those are joined to and it's still not bad, given the performance of v8.\n\nBut sometimes there really are too many related objects and performance suffers. So you may want to restrict the join to occur only if you have retrieved only *one* book, as on a \"show\" page for that book. Use the `ifOnlyOne` option:\n\n```javascript\n'stories': {\n  addFields: [\n    {\n      name: '_books',\n      withType: 'book',\n      ifOnlyOne: true,\n      label: 'Books'\n    }\n  ]\n}\n```\n\nNow any call to `schema.join` with only one object, or an array of only one object, will carry out the join with stories. Any call with more than one object won't.\n\nHint: in index views of many objects, consider using AJAX to load related objects when the user indicates interest rather than displaying related objects all the time.\n\n#### Reverse Many-To-Many Joins\n\nWe can also access the books from the story if we set the join up in the stories module as well:\n\n```javascript\n  addFields: [\n    {\n      name: '_books',\n      type: 'joinByArrayReverse',\n      withType: 'book',\n      idsField: 'storyIds',\n      label: 'Books'\n    }\n  ]\n}\n```\n\nNow we can access the `._books` property for any story. But users still must select stories when editing books, not the other way around.\n\n#### When Relationships Get Complicated\n\nWhat if each story comes with an author's note that is specific to each book? That's not a property of the book, or the story. It's a property of *the relationship between the book and the story*.\n\nIf the author's note for every each appearance of each story has to be super-fancy, with rich text and images, then you should make a new module that subclasses snippets in its own right and just join both books and stories to that new module. You can also use [array fields](#arrays-in-schemas) in creative ways to address this problem, using `joinByOne` as one of the fields of the schema in the array.\n\nBut if the relationship just has a few simple attributes, there is an easier way:\n\n```javascript\n  addFields: [\n    {\n      name: '_stories',\n      label: 'Stories',\n      type: 'joinByArray',\n      withType: 'story',\n      idsField: 'storyIds',\n      relationshipField: 'storyRelationships',\n      relationship: [\n        {\n          name: 'authorsNote',\n          type: 'string'\n        }\n      ],\n      sortable: true\n    }\n  ]\n```\n\nCurrently \"relationship\" properties can only be of type `string` (for text), `select` or `boolean` (for checkboxes). Otherwise they behave like regular schema properties.\n\n*Warning: the relationship field names `label` and `value` must not be used.* These names are reserved for internal implementation details.\n\nForm elements to edit relationship fields appear next to each entry in the list when adding stories to a book. So immediately after adding a story, you can edit its author's note.\n\nOnce we introduce the `relationship` option, our templates have to change a little bit. The `show` page for a book now looks like:\n\n```twig\n{% for story in item._stories %}\n  <h4>Story: {{ story.item.title | e }}</h4>\n  <h5>Author's Note: {{ story.relationship.authorsNote | e }}</h5>\n{% endfor %}\n```\n\nTwo important changes here: *the actual story is `story.item`*, not just `story`, and *relationship fields can be accessed via `story.relationship`*. This change kicks in when you use the `relationship` option.\n\nDoing it this way saves a lot of memory because we can still share book objects between stories and vice versa.\n\n#### Accessing Relationship Properties in a Reverse Join\n\nYou can do this in a reverse join too:\n\n```javascript\n  addFields: [\n    {\n      name: '_books',\n      type: 'joinByArrayReverse',\n      withType: 'book',\n      idsField: 'storyIds',\n      relationshipField: 'storyRelationships',\n      relationship: [\n        {\n          name: 'authorsNote',\n          type: 'string'\n        }\n      ]\n    }\n  ]\n```\n\nNow you can write:\n\n```twig\n{% for book in item._books %}\n  <h4>Book: {{ book.item.title | e }}</h4>\n  <h5>Author's Note: {{ book.relationship.authorsNote | e }}</h5>\n{% endfor %}\n```\n\nAs always, the relationship fields are edited only on the \"owning\" side (that is, when editing a book).\n\n*\"What is the `relationshipField` option for? I don't see `story_relationships` in the templates anywhere.\"*\n\nApostrophe stores the actual data for the relationship fields in `story_relationships`. But since it's not intuitive to write this in a template:\n\n```twig\n{# THIS IS THE HARD WAY #}\n{% for story in book._stories %}\n  {{ story.item.title | e }}\n  {{ book.story_relationships[story._id].authorsNote | e }}\n{% endif %}\n```\n\nApostrophe instead lets us write this:\n\n```twig\n{# THIS IS THE EASY WAY #}\n{% for story in book._stories %}\n  {{ story.item.title | e }}\n  {{ story.relationship.authorsNote | e }}\n{% endif %}\n```\n\n*Much better.*\n\n#### Specifying Joins When Calling schemas.join\n\nSometimes you won't want to honor all of the joins that exist in your schema. Other times you may wish to fetch more than your schema's `withJoin` options specify as a default behavior.\n\nYou can force `schemas.join` to honor specific joins by supplying a `withJoins` parameter:\n\n```javascript\nschemas.join(req, schema, objects, [ '_locations._events._promoters' ], callback);\n```\n\nThe syntax is exactly the same as for the `withJoins` option to individual joins in the schema, discussed earlier.\n\n### Overriding Templates For Individual Fields\n\nYou can override templates for individual fields without resorting to writing your own `new.html` and `edit.html` templates from scratch.\n\nHere's the `string.html` template that renders all fields with the `string` type by default:\n\n```html\n{% include \"schemaMacros.html\" %}\n{% if textarea %}\n  {{ formTextarea(name, label) }}\n{% else %}\n  {{ formText(name, label) }}\n{% endif %}\n```\n\nYou can override these for your project by creating new templates with the same names in the `lib/modules/apostrophe-schemas/views` folder. This lets you change the appearance for every field of a particular type. You should only override what you really wish to change.\n\nIn addition, you can specify an alternate template name for an individual field in your schema:\n\n{\n  type: 'integer',\n  name: 'shoeSize',\n  label: 'Shoe Size',\n  template: 'shoeSize'\n}\n\nThis will cause the `shoeSize.html` template to be rendered instead of the `integer.html` template.\n\nYou can also pass a `render` function, which receives the field object as its only parameter. Usually you'll find it much more convenient to just use a string and put your templates in `lib/modules/apostrophe-schemas/views`.\n\n### Adding New Field Types\n\nYou can add a new field type easily.\n\nOn the server side, we'll need to write three methods:\n\n* A \"render\" method that just renders a suitable Nunjucks template to insert this type of field in a form. Browser-side JavaScript will populate it with content later. Use the assets mixin in your module to make this code easy to write.\n* A converter for use when a form submission arrives.\n* A converter for use during CSV import of an object.\n\nThe converter's job is to ensure the content is really a list of strings and then populate the object with it. We pull the list from `data` (what the user submitted) and use it to populate `object`. We also have access to the field name (`name`) and, if we need it, the entire field object (`field`), which allows us to implement custom options.\n\nHere's an example of a custom field type: a simple list of strings.\n\n```javascript\n\n// Earlier in our module's constructor...\nself._apos.mixinModuleAssets(self, 'mymodulename', __dirname, options);\n// Now self.renderer is available\n\nschemas.addFieldType({\n  name: 'list',\n  render: self.renderer('schemaList'),\n  converters: {\n    form: function(req, data, name, object, field, callback) {\n      // Don't trust anything we get from the browser! Let's sanitize!\n\n      var maybe = _.isArray(data[name]) ? data[name] || [];\n\n      // Now build up a list of clean content\n      var yes = [];\n\n      _.each(maybe, function(item) {\n        if (field.max && (yes.length >= field.max)) {\n          // Limit the length of the list via a \"max\" property of the field\n          return;\n        }\n        // Only accept strings\n        if (typeof(item) === 'string') {\n          yes.push(item);\n        }\n      });\n      object[name] = yes;\n      return setImmmediate(function() {\n        return callback(null);\n      });\n    },\n\n    // CSV is a lot simpler because the input is always just\n    // a string. Split on \"|\" to allow more than one string in the list\n    csv: function(req, data, name, object, field, callback) {\n      object[name] = data[name].split('|');\n      return setImmediate(function() {\n        return callback(null);\n      });\n    }\n  }\n});\n```\n\nWe can also supply an optional `indexer` method to allow site-wide searches to locate this object based on the value of the field:\n\n```javascript\n  indexer: function(value, field, texts) {\n    var silent = (field.silent === undefined) ? true : field.silent;\n    texts.push({ weight: field.weight || 15, text: value.join(' '), silent: silent });\n  }\n```\n\nThe `views/schemaList.html` template should look like this. Note that the \"name\" and \"label\" options are passed to the template. In fact, all properties of the field that are part of the schema are available to the template. Setting `data-name` correctly is crucial. Adding a CSS class based on the field name is a nice touch but not required.\n\n```jinja\n<fieldset class=\"apos-fieldset my-fieldset-list apos-fieldset-{{ name | css}}\" data-name=\"{{ name }}\">\n  <label>{{ label | e }}</label>\n  {# Text entry for autocompleting the next item #}\n  <input name=\"{{ name | e }}\" data-autocomplete placeholder=\"Type Here\" class=\"autocomplete\" />\n  {# This markup is designed for jQuery Selective to show existing list items #}\n  <ul data-list class=\"my-list\">\n    <li data-item>\n      <span class=\"label-and-remove\">\n        <a href=\"#\" class=\"apos-tag-remove icon-remove\" data-remove></a>\n        <span data-label>Example label</span>\n      </span>\n    </li>\n  </ul>\n</fieldset>\n```\n\nNext, on the browser side, we need to supply two methods: a displayer and a converter.\n\n\"displayer\" is a method that populates the form field. `aposSchemas.populateFields` will invoke it.\n\n\"converter\" is a method that retrieves data from the form field and places it in an object. `aposSchemas.convertFields` will invoke it.\n\nHere's the browser-side code to add our \"list\" type:\n\n```javascript\naposSchemas.addFieldType({\n  name: 'list',\n  displayer: function(data, name, $field, $el, field, callback) {\n    // $field is the element with right \"name\" attribute, which is great\n    // for classic HTML form elements. But for this type we want the\n    // div with the right \"data-name\" attribute. So find it in $el\n    $field = $el.find('[data-name=\"' + name + '\"]');\n    // Use jQuery selective to power the list\n    $field.selective({\n      // pass the existing values in as label/value pairs to satisfy\n      // jQuery selective\n      data: [\n        _.map(data[name], function() {\n          return {\n            label: data[name],\n            value: data[name]\n          };\n        });\n      ],\n      // Allow the user to add new strings\n      add: true\n    });\n    // Be sure to invoke the callback\n    return callback();\n  },\n  converter: function(data, name, $field, $el, field, callback) {\n    $field = $el.find('[data-name=\"' + name + '\"]');\n    data[name] = $field.selective('get');\n    // Be sure to invoke the callback\n    return callback();\n  }\n});\n```\n\nThis code can live in `site.js`, or in a `js` file that you push as an asset from your project or an npm module. Make sure your module loads *after* `apostrophe-schema`.\n\n### Creating Schemas With Compose and Refine\n\nFor many applications just creating your own array of fields is fine. But if you are creating a subclass of another module that also uses schemas, and you want to adjust the schema, you'll be a lot happier if the superclass uses the `schemas.compose()` method to build up the schema via the `addFields`, `removeFields`, `orderFields` and occasionally `alterFields` options.\n\nHere's a simple example:\n\n```javascript\nschemas.compose({\n  addFields: [\n    {\n      name: 'title',\n      type: 'string',\n      label: 'Name'\n    },\n    {\n      name: 'age',\n      type: 'integer',\n      label: 'Age'\n    }\n  },\n  removeFields: [ 'age' ]\n  ]\n});\n```\n\nThis `compose` call adds two fields, then removes one of them. This makes it easy for subclasses to contribute to the object which a parent class will ultimately pass to `compose`. It often looks like this:\n\n```javascript\nvar schemas = require('apostrophe-schemas');\n\n// Superclass has title and age fields, also merges in any fields appended\n// to addFields by a subclass\n\nfunction MySuperclass(options) {\n  var self = this;\n  options.addFields = [\n    {\n      name: 'title',\n      type: 'string',\n      label: 'Name'\n    },\n    {\n      name: 'age',\n      type: 'integer',\n      label: 'Age'\n    }\n  ].concat(options.addFields || []);\n  self._schema = schemas.compose(options);\n}\n\n// Subclass removes the age field, adds the shoe size field\n\nfunction MySubclass(options) {\n  var self = this;\n  MySuperclass.call(self, {\n    addFields: [\n      {\n        name: 'shoeSize',\n        title: 'Shoe Size',\n        type: 'string'\n      }\n    ],\n    removeFields: [ 'age' ]\n  });\n}\n```\n\n#### Removing Fields\n\nYou can also specify a `removeFields` option which will remove some of the fields you passed to `addFields`.\n\nThis is useful if various subclasses are contributing to your schema.\n\n```javascript\nremoveFields: [ 'thumbnail', 'body' ]\n}\n```\n\n#### Changing the Order of Fields\n\nWhen adding fields, you can specify where you want them to appear relative to existing fields via the `before`, `after`, `start` and `end` options. This works great with the subclassing technique shown above:\n\n```javascript\naddFields: [\n  {\n    name: 'favoriteCookie',\n    type: 'string',\n    label: 'Favorite Cookie',\n    after: 'title'\n  }\n]\n```\n\nAny additional fields after `favoriteCookie` will be inserted with it, following the title field.\n\nUse the `before` option instead of `after` to cause a field to appear before another field.\n\nUse `start: true` to cause a field to appear at the top.\n\nUse `start: end` to cause a field to appear at the end.\n\nIf this is not enough, you can explicitly change the order of the fields with `orderFields`:\n\n```javascript\norderFields: [ 'year', 'specialness' ]\n```\n\nAny fields you do not specify will appear in the original order, after the last field you do specify (use `removeFields` if you want a field to go away).\n\n#### Requiring Many Fields\n\nAlthough `required: true` works well, if you are subclassing and you wish to require a number of previously optional fields, the `requiredFields` option is more convenient. This is especially handy when working with `apostrophe-moderator`:\n\n```javascript\nrequireFields: [ 'title', 'startDate', 'body' ]\n```\n\n#### Altering Fields: The Easy Way\n\nYou can specify the same field twice in your `addFields` array. The last occurrence wins.\n\n#### Altering Fields: The Hard Way\n\nThere is also an `alterFields` option available. This must be a function which receives the schema (an array of fields) as its argument and modifies it. Most of the time you will not need this option; see `removeFields`, `addFields`, `orderFields` and `requireFields`. It is mostly useful if you want to make one small change to a field that is already rather complicated. Note you must modify the existing array of fields \"in place.\"\n\n#### Refining Existing Schemas With `refine`\n\nSometimes you'll want a modified version of an existing schema. `schemas.refine` is the simplest way to do this:\n\nvar newSchema = schemas.refine(schema, {\n  addFields: ...,\n  removeFields ..., etc\n});\n\nThe options are exactly the same as the options to `compose`. The returned array is a copy. No modifications are made to the original schema array.\n\n",
  "readmeFilename": "README.md",
  "_id": "apostrophe-schemas@0.5.32",
  "_from": "apostrophe-schemas@~0.5.x"
}
